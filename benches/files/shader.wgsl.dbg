Code("// todo: I need f16 in order to optimize the various varinings in the frament shader\r")
Code("//enable f16;\r")
Code("\r")
Code("@group(0) @binding(0)\r")
Code("var<storage> data: array<u32>;\r")
Code("\r")
Code("@group(1) @binding(0) var texture_color: texture_2d<f32>;\r")
Code("@group(1) @binding(1) var texture_sampler: sampler;\r")
Code("\r")
Code("fn rd_f32(offset: u32) -> f32 {\r")
Code("    return bitcast<f32>(data[offset]);\r")
Code("}\r")
Code("\r")
Code("fn rd_vec2f32(offset: u32) -> vec2<f32> {\r")
Code("    return vec2<f32>(rd_f32(offset), rd_f32(offset + 1u));\r")
Code("}\r")
Code("\r")
Code("// read a sRGB and convert it to linear space for blending, this conversion is done in shader because\r")
Code("// the limited precision of the 32-bit colors make more suitable to store them in the gamma space as opose to linear space,\r")
Code("// more on: http://poynton.ca/notes/color/GammaFQA.html, https://en.wikipedia.org/wiki/Gamma_correction#Explanation\r")
Code("// gamma conversion taken from https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear\r")
Code("fn rd_srgb(offset: u32) -> vec4<f32> {\r")
Code("    let srgb = unpack4x8unorm(data[offset]);\r")
Directive("if", Some(Raw("LINEAR_SPACE\r")))
Code("    // default gamma correction\r")
Code("    return vec4<f32>(pow(srgb, vec4<f32>(2.2)).rgb, srgb.a);\r")
Directive("else\r", None)
Code("    // blend in srgb space\r")
Code("    return srgb;\r")
Directive("endif\r", None)
Code("}\r")
Code("\r")
Code("fn rd_vec4f32(offset: u32) -> vec4<f32> {\r")
Code("    return vec4<f32>(rd_f32(offset), rd_f32(offset + 1u), rd_f32(offset + 2u), rd_f32(offset + 3u));\r")
Code("}\r")
Code("\r")
Code("fn rd_mat4x4f32(offset: u32) -> mat4x4<f32> {\r")
Code("    return mat4x4<f32>(\r")
Code("        rd_f32(offset),\r")
Code("        rd_f32(offset +  1u),\r")
Code("        rd_f32(offset +  2u),\r")
Code("        rd_f32(offset +  3u),\r")
Code("        rd_f32(offset +  4u),\r")
Code("        rd_f32(offset +  5u),\r")
Code("        rd_f32(offset +  6u),\r")
Code("        rd_f32(offset +  7u),\r")
Code("        rd_f32(offset +  8u),\r")
Code("        rd_f32(offset +  9u),\r")
Code("        rd_f32(offset + 10u),\r")
Code("        rd_f32(offset + 11u),\r")
Code("        rd_f32(offset + 12u),\r")
Code("        rd_f32(offset + 13u),\r")
Code("        rd_f32(offset + 14u),\r")
Code("        rd_f32(offset + 15u),\r")
Code("    );\r")
Code("}\r")
Code("\r")
Code("fn bezier2(t: f32, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> vec2<f32> {\r")
Code("    let d = 1.0 - t;\r")
Code("    return d * d * d * p0 + 3.0 * d * d * t * p1 + 3.0 * d * t * t * p2 + t * t * t * p3;\r")
Code("}\r")
Code("\r")
Code("fn bezier_normal2(t: f32, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> vec2<f32> {\r")
Code("    let t = (-3.0 * p0 + 9.0 * p1 - 9.0 * p2 + 3.0 * p3) * (t * t)\r")
Code("        + (6.0 * p0 - 12.0 * p1 + 6.0 * p2) * t\r")
Code("        - 3.0 * p0\r")
Code("        + 3.0 * p1;\r")
Code("    return vec2<f32>(-t.y, t.x);\r")
Code("}\r")
Code("\r")
Code("// todo: use f16\r")
Code("struct Vertex {\r")
Code("    // position in clip space\r")
Code("    @builtin(position) pos_cs: vec4<f32>,\r")
Code("    @location(0) uv: vec2<f32>,\r")
Code("    @location(1) @interpolate(flat) color: vec4<f32>, // color inpterolation isn't used, so it should be marked as flat\r")
Code("    @location(2) @interpolate(flat) p_offset: u32, // p_offset is used in in the selectionable render pass\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("    // screen space\r")
Code("    @location(3) pos_ss: vec2<f32>,\r")
Code("    // constants\r")
Code("    @location(4) @interpolate(flat) clip_ss: vec4<f32>,\r")
Directive("endif\r", None)
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("    @location(5) @interpolate(flat) fade_ss: vec2<f32>,\r")
Directive("endif\r", None)
Directive("if", Some(Raw("SDF_MASKING\r")))
Code("    // styling\r")
Code("    @location(6) uv_mask: vec2<f32>,\r")
Code("    @location(7) @interpolate(flat) style: vec4<f32>, // dilate, stroke, drop shadown, outter glow, inner glow\r")
Code("    @location(8) @interpolate(flat) stroke_color: vec3<f32>,\r")
Code("    @location(9) @interpolate(flat) shadow_color: vec4<f32>,\r")
Code("    @location(10) @interpolate(flat) outterglow_color: vec4<f32>,\r")
Directive("endif\r", None)
Code("    // @location(11) @interpolate(flat) debug: vec4<f32>,\r")
Code("};\r")
Code("\r")
Code("fn build_primitive_vertex(primitive: u32) -> Vertex {\r")
Code("    // unpack primitive\r")
Code("    // [31.. type ..30|29.. primitive index ..24|23.. primitive offset  ..0]\r")
Code("    let p_offset = extractBits(primitive,  0u, 24u);\r")
Code("    let p_index  = extractBits(primitive, 24u,  6u);\r")
Code("    let p_type   = extractBits(primitive, 30u,  2u);\r")
Code("\r")
Code("    var v: Vertex;\r")
Code("    v.p_offset = p_offset;\r")
Code("    var pos_ss: vec2<f32>;\r")
Code("\r")
Code("    switch (p_type) {\r")
Code("        case 0u: { // handle rectangle\r")
Code("            let shape = rd_vec4f32(p_offset);\r")
Code("            let shape_size = shape.zw - shape.xy;\r")
Code("            let uv = rd_vec4f32(p_offset + 4u);\r")
Code("            v.color = rd_srgb(p_offset + 8u);\r")
Code("            let clip_offset = data[p_offset + 9u];\r")
Code("            let clip = rd_vec4f32(clip_offset);\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("            var rot = rd_f32(p_offset + 10u);\r")
Code("            let hshear = rd_f32(p_offset + 11u);\r")
Code("            var pivot = rd_vec2f32(p_offset + 12u);\r")
Code("\r")
Code("            // pivot in screen space\r")
Code("            pivot = pivot * shape_size + shape.xy;\r")
Directive("endif\r", None)
Code("\r")
Code("            switch (p_index) {\r")
Code("                case 0u: { // bottom left\r")
Code("                    pos_ss = shape.xy;\r")
Code("                    v.uv = uv.xy;\r")
Code("                }\r")
Code("                case 1u: { // bottom right\r")
Code("                    pos_ss = vec2<f32>(shape.z, shape.y);\r")
Code("                    v.uv = vec2<f32>(uv.z, uv.y);\r")
Code("                }\r")
Code("                case 2u: { // top left\r")
Code("                    pos_ss = vec2<f32>(shape.x, shape.w);\r")
Code("                    v.uv = vec2<f32>(uv.x, uv.w);\r")
Code("                }  \r")
Code("                case 3u: { // top right\r")
Code("                    pos_ss = shape.zw;\r")
Code("                    v.uv = uv.zw;\r")
Code("                } \r")
Code("                default: {\r")
Code("                    pos_ss = vec2<f32>(0.0, 0.0);\r")
Code("                    v.uv = vec2<f32>(0.0, 0.0);\r")
Code("                }\r")
Code("            }\r")
Code("\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("            // enable or not vertex cliping\r")
Code("            rot = fract(rot / 6.283185307179586476925286766559) * 6.283185307179586476925286766559; // wrap around 2 pi\r")
Code("            if (abs(rot) < 1e-9 && abs(hshear) < 1e-9) {\r")
Directive("endif\r", None)
Code("                let tmp = clamp(pos_ss, clip.xy, clip.zw);\r")
Code("                v.uv = v.uv + ((tmp - pos_ss) / max(shape_size, vec2<f32>(1e-9, 1e-9)) * (uv.zw - uv.xy));\r")
Code("                pos_ss = tmp;\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("            } else {\r")
Code("                // apply transform\r")
Code("                let s = sin(rot);\r")
Code("                let c = cos(rot);\r")
Code("                pos_ss = pos_ss - pivot;\r")
Code("                // | c, s| * |1, hshear| = | c, s + c * hshear |\r")
Code("                // |-s, c|   |0,      1|   |-s, c - s * hshear |\r")
Code("                pos_ss = mat2x2<f32>(c, -s, s + c * hshear, c - s * hshear) * pos_ss;\r")
Code("                pos_ss = pos_ss + pivot;\r")
Code("            }\r")
Directive("endif\r", None)
Code("\r")
Code("            // clip rectangle is in screen space coordinates\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("            v.clip_ss = clip;\r")
Directive("endif\r", None)
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("            // todo: fix fade to support all TBLR the components\r")
Code("            v.fade_ss = rd_vec4f32(clip_offset + 4u).xz;\r")
Directive("endif\r", None)
Code("        }\r")
Code("        case 1u: { // handle sliced rectangle\r")
Code("\r")
Code("\r")
Code("            pos_ss = vec2<f32>(0.0, 0.0);\r")
Code("            v.uv = vec2<f32>(0.0, 0.0);\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("            v.clip_ss = vec4<f32>(0.0, 0.0, 0.0, 0.0);\r")
Directive("endif\r", None)
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("            v.fade_ss = vec2<f32>(0.0, 0.0);\r")
Directive("endif\r", None)
Code("\r")
Code("            var shape = rd_vec4f32(p_offset);\r")
Code("            let shape_size = shape.zw - shape.xy;\r")
Code("            var uv = rd_vec4f32(p_offset + 4u);\r")
Code("            let uv_size = uv.zw - uv.xy;\r")
Code("            let borders = rd_vec4f32(p_offset + 8u);\r")
Code("            let border_scale = rd_f32(p_offset + 12u);\r")
Code("            v.color = rd_srgb(p_offset + 13u);\r")
Code("            let clip_offset = data[p_offset + 14u];\r")
Code("            let clip = rd_vec4f32(clip_offset);\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("            var rot = rd_f32(p_offset + 16u);\r")
Code("            let hshear = rd_f32(p_offset + 17u);\r")
Code("            var pivot = rd_vec2f32(p_offset + 18u);\r")
Code("\r")
Code("            // pivot in screen space\r")
Code("            pivot = pivot * shape_size + shape.xy;\r")
Directive("endif\r", None)
Code("\r")
Code("            let texture_size = rd_vec2f32(20u); // only read the first 2 floats of texture_params\r")
Code("            var shape_borders = borders * ((uv_size * texture_size) * border_scale).yyxx;\r")
Code("\r")
Code("            // uniform rescale borders when there's no space left\r")
Code("            let req = shape_borders.xz + shape_borders.yw;\r")
Code("            let scale = clamp(min(shape_size.x, shape_size.y) / max(req.x, req.y), 0.0, 1.0);\r")
Code("            shape_borders = shape_borders * scale;\r")
Code("\r")
Code("            let corner = extractBits(p_index, 0u, 2u);\r")
Code("            let slice  = extractBits(p_index, 2u, 4u);\r")
Code("\r")
Code("            // todo: don't stretch sides if too big (hard and expensive without extra geometry)\r")
Code("            // todo: don't squeeze sides if too short insted clamp\r")
Code("\r")
Code("            // slices representation\r")
Code("            // ┌───┬───┬───┐ \r")
Code("            // │ 6 │ 7 │ 8 │\r")
Code("            // ├───┼───┼───┤ \r")
Code("            // │ 3 │ 4 │ 5 │\r")
Code("            // ├───┼───┼───┤\r")
Code("            // │ 0 │ 1 │ 2 │\r")
Code("            // └───┴───┴───┘ \r")
Code("            switch (slice) {\r")
Code("                case 0u: {\r")
Code("                    shape.z = shape.x + shape_borders.z;\r")
Code("                    shape.y = shape.w - shape_borders.y;\r")
Code("                    uv.z = uv.x + uv_size.x * borders.z;\r")
Code("                    uv.y = uv.w - uv_size.y * borders.y;\r")
Code("                }\r")
Code("                case 1u: {\r")
Code("                    shape.x = shape.x + shape_borders.z;\r")
Code("                    shape.z = shape.z - shape_borders.w;\r")
Code("                    shape.y = shape.w - shape_borders.y;\r")
Code("                    uv.x = uv.x + uv_size.x * borders.z;\r")
Code("                    uv.z = uv.z - uv_size.x * borders.w;\r")
Code("                    uv.y = uv.w - uv_size.y * borders.y;\r")
Code("                }\r")
Code("                case 2u: {\r")
Code("                    shape.x = shape.z - shape_borders.w;\r")
Code("                    shape.y = shape.w - shape_borders.y;\r")
Code("                    uv.x = uv.z - uv_size.x * borders.w;\r")
Code("                    uv.y = uv.w - uv_size.y * borders.y;\r")
Code("                }\r")
Code("                case 3u: {\r")
Code("                    shape.z = shape.x + shape_borders.z;\r")
Code("                    shape.y = shape.y + shape_borders.x;\r")
Code("                    shape.w = shape.w - shape_borders.y;\r")
Code("                    uv.z = uv.x + uv_size.x * borders.z;\r")
Code("                    uv.y = uv.y + uv_size.y * borders.x;\r")
Code("                    uv.w = uv.w - uv_size.y * borders.y;\r")
Code("                }\r")
Code("                case 4u: {\r")
Code("                    shape.x = shape.x + shape_borders.z;\r")
Code("                    shape.z = shape.z - shape_borders.w;\r")
Code("                    shape.y = shape.y + shape_borders.x;\r")
Code("                    shape.w = shape.w - shape_borders.y;\r")
Code("                    uv.x = uv.x + uv_size.x * borders.z;\r")
Code("                    uv.z = uv.z - uv_size.x * borders.w;\r")
Code("                    uv.y = uv.y + uv_size.y * borders.x;\r")
Code("                    uv.w = uv.w - uv_size.y * borders.y;\r")
Code("                }\r")
Code("                case 5u: {\r")
Code("                    shape.x = shape.z - shape_borders.w;\r")
Code("                    shape.y = shape.y + shape_borders.x;\r")
Code("                    shape.w = shape.w - shape_borders.y;\r")
Code("                    uv.x = uv.z - uv_size.x * borders.w;\r")
Code("                    uv.y = uv.y + uv_size.y * borders.x;\r")
Code("                    uv.w = uv.w - uv_size.y * borders.y;\r")
Code("                }\r")
Code("                case 6u: {\r")
Code("                    shape.z = shape.x + shape_borders.z;\r")
Code("                    shape.w = shape.y + shape_borders.x;\r")
Code("                    uv.z = uv.x + uv_size.x * borders.z;\r")
Code("                    uv.w = uv.y + uv_size.y * borders.x;\r")
Code("                }\r")
Code("                case 7u: {\r")
Code("                    shape.x = shape.x + shape_borders.z;\r")
Code("                    shape.z = shape.z - shape_borders.w;\r")
Code("                    shape.w = shape.y + shape_borders.x;\r")
Code("                    uv.x = uv.x + uv_size.x * borders.z;\r")
Code("                    uv.z = uv.z - uv_size.x * borders.w;\r")
Code("                    uv.w = uv.y + uv_size.y * borders.x;\r")
Code("                }\r")
Code("                case 8u: {\r")
Code("                    shape.x = shape.z - shape_borders.w;\r")
Code("                    shape.w = shape.y + shape_borders.x;\r")
Code("                    uv.x = uv.z - uv_size.x * borders.w;\r")
Code("                    uv.w = uv.y + uv_size.y * borders.x;\r")
Code("                }\r")
Code("                default: {\r")
Code("                    // invalid side don't draw\r")
Code("                    shape = shape.xyxy;\r")
Code("                }\r")
Code("            }\r")
Code("\r")
Code("            switch (corner) {\r")
Code("                case 0u: { // bottom left\r")
Code("                    pos_ss = shape.xy;\r")
Code("                    v.uv = uv.xy;\r")
Code("                }\r")
Code("                case 1u: { // bottom right\r")
Code("                    pos_ss = vec2<f32>(shape.z, shape.y);\r")
Code("                    v.uv = vec2<f32>(uv.z, uv.y);\r")
Code("                }\r")
Code("                case 2u: { // top left\r")
Code("                    pos_ss = vec2<f32>(shape.x, shape.w);\r")
Code("                    v.uv = vec2<f32>(uv.x, uv.w);\r")
Code("                }  \r")
Code("                case 3u: { // top right\r")
Code("                    pos_ss = shape.zw;\r")
Code("                    v.uv = uv.zw;\r")
Code("                } \r")
Code("                default: { \r")
Code("                    pos_ss = vec2<f32>(0.0, 0.0);\r")
Code("                    v.uv = vec2<f32>(0.0, 0.0);\r")
Code("                }\r")
Code("            }\r")
Code("\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("            // enable or not vertex cliping\r")
Code("            rot = fract(rot / 6.283185307179586476925286766559) * 6.283185307179586476925286766559; // wrap around 2 pi\r")
Code("            if (abs(rot) < 1e-9 && abs(hshear) < 1e-9) {\r")
Directive("endif\r", None)
Code("                let tmp = clamp(pos_ss, clip.xy, clip.zw);\r")
Code("                v.uv = v.uv + ((tmp - pos_ss) / max(shape_size, vec2<f32>(1e-9, 1e-9)) * uv_size);\r")
Code("                pos_ss = tmp;\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("            } else {\r")
Code("                // apply transform\r")
Code("                let s = sin(rot);\r")
Code("                let c = cos(rot);\r")
Code("                pos_ss = pos_ss - pivot;\r")
Code("                // | c, s| * |1, hshear| = | c, s + c * hshear |\r")
Code("                // |-s, c|   |0,      1|   |-s, c - s * hshear |\r")
Code("                pos_ss = mat2x2<f32>(c, -s, s + c * hshear, c - s * hshear) * pos_ss;\r")
Code("                pos_ss = pos_ss + pivot;\r")
Code("            }\r")
Directive("endif\r", None)
Code("\r")
Code("            // clip rectangle is in screen space coordinates\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("            v.clip_ss = clip;\r")
Directive("endif\r", None)
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("            // todo: fix fade to support all TBLR the components\r")
Code("            v.fade_ss = rd_vec4f32(clip_offset + 4u).xz;\r")
Directive("endif\r", None)
Code("        }\r")
Directive("if", Some(Raw("EXTRA_PRIMITIVES\r")))
Code("        case 2u: { // handle bezier\r")
Code("            var uv = rd_vec4f32(p_offset);\r")
Code("            var p0 = rd_vec2f32(p_offset + 4u);\r")
Code("            var p1 = rd_vec2f32(p_offset + 6u);\r")
Code("            var p2 = rd_vec2f32(p_offset + 8u);\r")
Code("            var p3 = rd_vec2f32(p_offset + 10u);\r")
Code("            var width = rd_f32(p_offset + 12u);\r")
Code("            v.color = rd_srgb(p_offset + 13u);\r")
Code("            let clip_offset = data[p_offset + 14u];\r")
Code("            let factor = rd_f32(p_offset + 15u);\r")
Code("\r")
Code("            let index = f32(extractBits(p_index, 0u, 5u));\r")
Code("            let t = index * factor;\r")
Code("            let ceil = f32(extractBits(p_index, 5u, 1u));\r")
Code("            let sign = sign(ceil - 0.5);\r")
Code("            var normal = sign * width * normalize(bezier_normal2(t, p0, p1, p2, p3));\r")
Code("\r")
Code("            pos_ss = bezier2(t, p0, p1, p2, p3) + normal;\r")
Code("            //v.uv = (uv.zw - uv.xy) * vec2<f32>(t, ceil) + uv.xy; // fast lerp\r")
Code("            v.uv = (vec2<f32>(1.0, 1.0) - t) * uv.xy + t * uv.zw; // precise lerp\r")
Code("\r")
Code("            // clip rectangle is in screen space coordinates\r")
Code("            v.clip_ss = rd_vec4f32(clip_offset);\r")
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("            // todo: fix fade to support all TBLR the components\r")
Code("            v.fade_ss = rd_vec4f32(clip_offset + 4u).xz;\r")
Directive("endif\r", None)
Code("        }\r")
Code("        case 3u: { // handle meshlet\r")
Code("            v.color = rd_srgb(p_offset);\r")
Code("            let clip_offset = data[p_offset + 1u];\r")
Code("            let tmp = rd_vec4f32(p_offset + 4u + p_index * 4u);\r")
Code("            pos_ss = tmp.xy;\r")
Code("            v.uv = tmp.zw;\r")
Code("\r")
Code("            // clip rectangle is in screen space coordinates\r")
Code("            v.clip_ss = rd_vec4f32(clip_offset);\r")
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("            // todo: fix fade to support all TBLR the components\r")
Code("            v.fade_ss = rd_vec4f32(clip_offset + 4u).xz;\r")
Directive("endif\r", None)
Code("        }\r")
Directive("endif", Some(Raw("// EXTRA_PRIMITIVES\r")))
Code("        default: {\r")
Code("            pos_ss = vec2<f32>(0.0, 0.0);\r")
Code("        }\r")
Code("    }\r")
Code("\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("    // save position while still in screen space\r")
Code("    v.pos_ss = pos_ss;\r")
Directive("endif\r", None)
Code("\r")
Code("    // final position\r")
Code("    v.pos_cs = vec4<f32>(pos_ss, 0.0, 1.0);\r")
Code("\r")
Code("    return v;\r")
Code("}\r")
Code("\r")
Directive("if", Some(Raw("NON_INDEXED\r")))
Code("// todo: currently unused, by giving up the hability of having other kinds of primitives other than a quad\r")
Code("// we can avoid having a index buffer and thus hopefully reducing the ammount of data we have to\r")
Code("// send o the GPU\r")
Code("//\r")
Code("// meant to be used with a triangle list\r")
Code("fn build_non_indexed_rectangle_vertex(i: u32) -> Vertex {\r")
Code("    let r_index = i / 6u; // each rectangles uses 6 vertices, 2 triangles\r")
Code("    let p_offset = r_index + 28u; // rectangle index plus the common data offset\r")
Code("    let vert_index  = i - (r_index * 6u); // vertice index\r")
Code("\r")
Code("    var v: Vertex;\r")
Code("    v.p_offset = p_offset;\r")
Code("    var pos_ss: vec2<f32>;\r")
Code("\r")
Code("    let shape = rd_vec4f32(p_offset);\r")
Code("    let shape_size = shape.zw - shape.xy;\r")
Code("    let uv = rd_vec4f32(p_offset + 4u);\r")
Code("    v.color = rd_srgb(p_offset + 8u);\r")
Code("    let clip_offset = data[p_offset + 9u];\r")
Code("    let clip = rd_vec4f32(clip_offset);\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("    var rot = rd_f32(p_offset + 10u);\r")
Code("    let hshear = rd_f32(p_offset + 11u);\r")
Code("    var pivot = rd_vec2f32(p_offset + 12u);\r")
Code("\r")
Code("    // pivot in screen space\r")
Code("    pivot = pivot * shape_size + shape.xy;\r")
Directive("endif\r", None)
Code("\r")
Code("    // translate vertex index to rectangle corner\r")
Code("    // vert_index: 0, 1, 2, 3, 4, 5\r")
Code("    // corner:     0, 3, 1, 3, 0, 2\r")
Code("    switch (vert_index) {\r")
Code("        case 0u, 4u { // corner: 0 (bottom left)\r")
Code("            pos_ss = shape.xy;\r")
Code("            v.uv = uv.xy;\r")
Code("        }\r")
Code("        case 2u { // corner: 1 (bottom right)\r")
Code("            pos_ss = shape.zy;\r")
Code("            v.uv = uv.zy;\r")
Code("        }\r")
Code("        case 5u { // corner: 2 (top left)\r")
Code("            pos_ss = shape.xw;\r")
Code("            v.uv = uv.xw;\r")
Code("        }  \r")
Code("        case 1u, 3u { // corner: 3 (top right)\r")
Code("            pos_ss = shape.zw;\r")
Code("            v.uv = uv.zw;\r")
Code("        } \r")
Code("        default: {\r")
Code("            pos_ss = vec2<f32>(0.0, 0.0);\r")
Code("            v.uv = vec2<f32>(0.0, 0.0);\r")
Code("        }\r")
Code("    }\r")
Code("\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("    // enable or not vertex cliping\r")
Code("    rot = fract(rot / 6.283185307179586476925286766559) * 6.283185307179586476925286766559; // wrap around 2 pi\r")
Code("    if (abs(rot) < 1e-9 && abs(hshear) < 1e-9) {\r")
Directive("endif\r", None)
Code("        let tmp = clamp(pos_ss, clip.xy, clip.zw);\r")
Code("        v.uv = v.uv + ((tmp - pos_ss) / max(shape_size, vec2<f32>(1e-9, 1e-9)) * (uv.zw - uv.xy));\r")
Code("        pos_ss = tmp;\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("    } else {\r")
Code("        // apply transform\r")
Code("        let s = sin(rot);\r")
Code("        let c = cos(rot);\r")
Code("        pos_ss = pos_ss - pivot;\r")
Code("        // | c, s| * |1, hshear| = | c, s + c * hshear |\r")
Code("        // |-s, c|   |0,      1|   |-s, c - s * hshear |\r")
Code("        pos_ss = mat2x2<f32>(c, -s, s + c * hshear, c - s * hshear) * pos_ss;\r")
Code("        pos_ss = pos_ss + pivot;\r")
Code("    }\r")
Directive("endif\r", None)
Code("\r")
Code("    // clip rectangle is in screen space coordinates\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("    v.clip_ss = clip;\r")
Directive("endif\r", None)
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("    // todo: fix fade to support all TBLR the components\r")
Code("    v.fade_ss = rd_vec4f32(clip_offset + 4u).xz;\r")
Directive("endif\r", None)
Code("\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("    // save position while still in screen space\r")
Code("    v.pos_ss = pos_ss; // hi?\r")
Directive("endif\r", None)
Code("\r")
Code("    // final position\r")
Code("    v.pos_cs = vec4<f32>(pos_ss, 0.0, 1.0);\r")
Code("\r")
Code("    return v;\r")
Code("}\r")
Directive("endif\r", None)
Code("\r")
Code("@vertex\r")
Code("fn vs_color(@builtin(vertex_index) p: u32) -> Vertex {\r")
Code("    var v = build_primitive_vertex(p);\r")
Code("\r")
Code("    // apply transform to clip space\r")
Code("    let transform = rd_mat4x4f32(0u);\r")
Code("    v.pos_cs = transform * v.pos_cs;\r")
Code("\r")
Code("    return v;\r")
Code("}\r")
Code("\r")
Code("@fragment\r")
Code("fn fs_color(in: Vertex) -> @location(0) vec4<f32> {\r")
Code("    var out = textureSample(texture_color, texture_sampler, in.uv);\r")
Code("\r")
Directive("if", Some(Raw("TRANSFORM || CLIP_FADE\r")))
Code("    // per pixel cliping, to support transformations, complex shapes and fade borders\r")
Code("    let p = in.pos_ss.xy;\r")
Code("    let p_min = p - in.clip_ss.xy;\r")
Code("    let p_max = p - in.clip_ss.zw;\r")
Code("    if (p_min.x < 0.0 || p_max.x > 0.0 || p_min.y < 0.0 || p_max.y > 0.0) {\r")
Code("        discard;\r")
Code("    }\r")
Directive("endif\r", None)
Code("\r")
Directive("if", Some(Raw("CLIP_FADE\r")))
Code("    // clip fade\r")
Code("    let d = min(abs(p_max), p_min) * in.fade_ss;\r")
Code("\r")
Code("    // rectangular fade\r")
Code("    // let fade = min(min(d.x, d.y), 1.0);\r")
Code("\r")
Code("    // rounded fade\r")
Code("    // todo: add a third multiplification factor in `d.x * d.y * other_factor` lower than 1.0 to better round the edges\r")
Code("    let fade = clamp(min(d.x * d.y, min(d.x, d.y)), 0.0, 1.0);\r")
Code("\r")
Code("    // fade\r")
Code("    out.a = out.a * fade;\r")
Directive("endif\r", None)
Code("\r")
Directive("if", Some(Raw("SDF_MASKING\r")))
Code("    // todo: sdf masking\r")
Directive("endif\r", None)
Code("\r")
Code("    // color\r")
Code("    out = in.color * out;\r")
Code("\r")
Code("    return out;\r")
Code("}\r")
Code("\r")
Code("\r")
Code("@vertex\r")
Code("fn vs_selection(@builtin(vertex_index) p: u32) -> Vertex {\r")
Code("    var v = build_primitive_vertex(p);\r")
Code("\r")
Code("    // to clip space, but using the selection params\r")
Code("    var normalize = rd_vec2f32(24u);\r")
Code("    var offset = -rd_vec2f32(26u);\r")
Code("    v.pos_cs = vec4<f32>((v.pos_cs.xy + offset) * normalize * 2.0 - 1.0, v.pos_cs.zw);\r")
Code("\r")
Code("    return v;\r")
Code("}\r")
Code("\r")
Code("@fragment\r")
Code("fn fs_selection(in: Vertex) -> @location(0) u32 {\r")
Code("    var out = textureSample(texture_color, texture_sampler, in.uv);\r")
Code("\r")
Directive("if", Some(Raw("TRANSFORM\r")))
Code("    // per pixel cliping, to support transformations, complex shapes and fade borders\r")
Code("    let p = in.pos_ss.xy;\r")
Code("    let p_min = p - in.clip_ss.xy;\r")
Code("    let p_max = p - in.clip_ss.zw;\r")
Code("    if (p_min.x < 0.0 || p_max.x > 0.0 || p_min.y < 0.0 || p_max.y > 0.0) {\r")
Code("        discard;\r")
Code("    }\r")
Directive("endif\r", None)
Code("\r")
Code("    // doesn't do clip fade because the primitive will remain selectable unless fully transparent\r")
Code("\r")
Directive("if", Some(Raw("SDF_MASKING\r")))
Code("    // todo: sdf masking\r")
Directive("endif\r", None)
Code("\r")
Code("    // alpha clip\r")
Code("    if (out.a <= 1.0e-6) {\r")
Code("        discard;\r")
Code("    }\r")
Code("\r")
Code("    return in.p_offset;\r")
Code("}\r")
Code("\r")
Code("// @vertex\r")
Code("// fn vs_fullscreen_triangle([[builtin(vertex_index)]] i: u32) -> [[builtin(position)]] vec4<f32> {\r")
Code("// \tlet uv = vec2<f32>(f32((i << 1u) & 2u), f32(i & 2u));\r")
Code("// \treturn vec4<f32>((2.0 * uv) - vec2<f32>(1.0, 1.0), 0.0, 1.0);\r")
Code("// }\r")
Code("\r")
Code("// @fragment\r")
Code("// fn fs_selection_clear() -> [[location(0)]] u32 {\r")
Code("//     return 4294967295u; // 0xffffffff;\r")
Code("// }")
